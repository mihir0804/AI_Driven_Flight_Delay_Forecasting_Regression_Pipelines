# -*- coding: utf-8 -*-
"""AirPredictAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aY3vIkN8hb0MwgBnw0F0orBBSOOkJRqO

![flights ml project png.jpg](data:image/jpeg;base64,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)

This project has a record of flight details from Washington,DC area into New York city during the year of 2004 in the month of January. The main aim of the project is to predict if a new flight will be delayed or not from the provided data using 'MACHINE LEARNING'

PART 1 of this would be an Exploratory Data Analysis where various features(columns) in the provided dataset will be analyzed using various methods to interpret their relation and visualize them

PART 2 will be Model Training based on Naive Bayes theorem and train them to pedict whether the flight arrives at ontime or it gets delayed.

#### **Highlights of the data**

#### **The data consists of 10 features (columns) namely**

- Carrier
- Departure_Time
- Destination
- Date
- Flight_Number
- Origin
- Day_of_the_Week
- Day_of_the_Month

#### **Day of the Week**
**Each number represents the corresponding day**
- 1- Monday
- 2- Tuesday
- 3- Wednesday
- 4- Thursday
- 5- Friday
- 6- Saturday
- 7- Sunday

#### Day of the Month
Each number represents the days in a month.

#### Abbreviations
#### Carrier

- CO - Continental
- DH - Atlantic Coast
- DL - Delta
- MQ - American Eagle
- OH - Comair
- RU - Continental Express
- UA - United
- US - USAirways

#### Destination

- JFK - Kennedy
- LGA - LaGuardia
- EWR - Newark

#### Origin

- DCA - Reagan National
- IAD - Dulles
- BWI - BaltimoreWashington Intl

# **EXPLORATORY DATA ANALYSIS**
"""

# Importing Data Manipulation Libraries
import pandas as pd
import numpy as np
# Import Data Visualization Libraries
import seaborn as sns
import matplotlib.pyplot as plt
# Import Filter Warning Libraries
import warnings
warnings.filterwarnings('ignore')
# Import Logging
import logging
logging.basicConfig(level = logging.INFO,
                    format = '%(asctime)s - %(levelname)s - %(message)s',
                    filemode = 'w',
                    filename = 'model.log',force = True)
# Import Scikit Learn Libraries for Machine Learning Model Building
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split,cross_val_score,GridSearchCV,learning_curve,KFold
from sklearn.metrics import mean_squared_error,mean_absolute_error,r2_score
from sklearn.linear_model import LinearRegression,Lasso,Ridge
from sklearn.tree import DecisionTreeRegressor
from sklearn.svm import SVR
from sklearn.neighbors import KNeighborsRegressor
from sklearn.ensemble import RandomForestRegressor, AdaBoostRegressor, GradientBoostingRegressor
import xgboost
from xgboost import XGBRegressor
from sklearn.cluster import KMeans


# Multicolinearity test and treatment libraries
from statsmodels.stats.outliers_influence import variance_inflation_factor
from sklearn.decomposition import PCA

# Importing Data using Pandas Function
df = pd.read_csv('/content/Flight-Data.csv')
# if file csv uplond in
# It will print Shuffle 100% Dataset
df.sample(frac = 1)

"""## **Displaying datatype information of the dataset**"""

# Checking Data Information
df.info()

# Checking Null Value
df.isnull().sum().plot(kind = 'barh')
plt.title('Null Values in Dataset')
plt.show()

"""## **The Entire details in the dataset is imported and displayed as 2199 rows and 10 columns**"""

#showing the first 5 rows
df.head()

#showing the Last 5 rows
df.tail()

#obtaining the shape of the dataset
df.shape

# Dataset Spliy Data
categorical_col = df.select_dtypes(include = 'object')
numerical_col = df.select_dtypes(exclude = 'object')
categorical_col

numerical_col

df

"""## **EDA : Explotatory Data Analysis [Univariat Analysis]**"""

def univariate_stats():
    import pandas as pd
    from collections import OrderedDict

    stats = []

    # Select numeric columns only
    numeric_cols = df.select_dtypes(include=['number']).columns

    for i in numeric_cols:
        s = df[i].dropna()  # drop NaNs to avoid issues
        numerical_stats = OrderedDict({
            'Feature': i,
            'Count': s.count(),
            'Minimum': s.min(),
            'Maximum': s.max(),
            'Mean': s.mean(),
            'Median': s.median(),
            'Q1': s.quantile(0.25),
            'Q3': s.quantile(0.75),
            'IQR': s.quantile(0.75) - s.quantile(0.25),
            'Standard Deviation': s.std(),
            'Skewness': s.skew(),
            'Kurtosis': s.kurtosis()
        })
        stats.append(numerical_stats)

    report = pd.DataFrame(stats)
    return report

# Usage
ans = univariate_stats()
ans

df.columns

"""## **As the column name in the dataset contains space in between two words, replacement of space with an underscore is done as the interpreter shows error in presence of space between words**"""

#renaming the column
df=df.rename(columns={'Delayed_':'Delayed'})
df

"""### **Statistical information of the dataset**"""

#statistical description of data
df.describe().transpose()

#to find the presence of null value
df.isnull().sum()

"""### **As the data doesn't contains any null and duplicate values,tideous process aren't involved while handling the data**

# **DATA PRE-PROCESSING**

As the Departure Time has both hours and minutes combined together, only hours is retained and minutes are removed off

- the first digits are taken as hours and last two digits as minutes
"""

#slicing only the hours from departure time
df['Departure Time']=df['Departure Time'].astype(str).str.zfill(4).str[:2].astype(int)
df

"""## **CORRELATION**

## **Correlation is an important statistical feature which shows the relationship between the variables in various visualization forms such as heatmaps.In this project,Pearson method of correlation is used to find the statistical relationship between the variables**
"""

#displaying the correlation between the columns of the flght dataset
correlation = df.select_dtypes(include=['number']).corr()
correlation

"""# **Correlation between the variables**"""

# Select numeric columns and create Pearson correlation
corr_df = df.select_dtypes(include=['number']).corr(method="pearson")

# Plot heatmap
plt.figure(figsize=(10,6))
heatmap = sns.heatmap(corr_df, annot=True, fmt=".1g", vmin=-1, vmax=1, center=0, cmap="summer", linewidths=1, linecolor="Black")
heatmap.set_title("CORRELATION HEATMAP BETWEEN VARIABLES")
heatmap.set_xticklabels(heatmap.get_xticklabels(), rotation=90)
plt.show()

"""## **DATA VISUALIZATION**"""

numeric_df = df.select_dtypes(include=['number'])

plt.figure(figsize=(8,6))
sns.heatmap(
    numeric_df.corr(),
    annot=True,
    fmt=".2f",
    cmap="coolwarm",
    center=0
)
plt.title("Correlation Heatmap of Numeric Features")
plt.show()

df.columns = df.columns.str.strip()
df['Delayed_numeric'] = df['Delayed'].map({'ontime':0, 'delayed':1})

fig, axes = plt.subplots(1,2, figsize=(14,5))

df.groupby('Carrier')['Delayed_numeric'].mean().plot(kind='bar', ax=axes[0], title='Delay Rate by Carrier')
df.groupby('Day of the Week')['Delayed_numeric'].mean().plot(kind='bar', ax=axes[1], title='Delay Rate by Day')

plt.tight_layout()
plt.show()

# Extract hour if not already done
df['Departure_Hour'] = df['Departure Time'].astype(int)

df.groupby('Departure_Hour')['Delayed_numeric'].mean().plot(kind='bar', figsize=(8,5))
plt.title("Delay Rate by Departure Hour")
plt.ylabel("Delay Rate")
plt.xlabel("Hour of Departure")
plt.ylim(0,1)
plt.show()

# Create distance bins
df['Distance_Bin'] = pd.cut(df['Distance'], bins=[0,100,200,300,400])

df.groupby('Distance_Bin')['Delayed_numeric'].mean().plot(kind='bar', figsize=(8,5))
plt.title("Delay Rate by Distance Range")
plt.ylabel("Delay Rate")
plt.xlabel("Distance Range")
plt.ylim(0,1)
plt.show()

sns.scatterplot(x='Distance', y='Delayed_numeric', data=df)
plt.title("Distance vs Delay")
plt.xlabel("Distance")
plt.ylabel("Delay (0=ontime,1=delayed)")
plt.show()

numeric_df = df.select_dtypes(include=['number'])

plt.figure(figsize=(8,6))
sns.heatmap(
    numeric_df.corr(),
    annot=True,
    fmt=".2f",
    cmap="coolwarm",
    center=0
)
plt.title("Correlation Heatmap of Numeric Features")
plt.show()

df.columns = df.columns.str.strip()

plt.barh(range(len(df)), df['Distance'])
plt.xlabel("Distance")
plt.ylabel("Flight Index")
plt.title("Distance per Flight")
plt.show()

# 1 Clean up column names (trailing spaces like 'Delayed ')
df.columns = df.columns.str.strip()

# 2 Convert 'Delayed' column to numeric (if not already)
df['Delayed_numeric'] = df['Delayed'].map({'ontime': 0, 'delayed': 1})

# 3 Create distance bins
df['Distance_bin'] = pd.cut(df['Distance'], bins=10)

# 4 Group by bin and calculate mean delay rate
delay_rate = df.groupby('Distance_bin')['Delayed_numeric'].mean().sort_index()

# 5 Plot horizontal bar chart
plt.figure(figsize=(10, 6))
delay_rate.plot(kind='barh', color='lightgreen', edgecolor='black')

plt.xlabel("Average Delay Rate")
plt.ylabel("Distance Range")
plt.title("Average Delay Rate per Distance Range")
plt.xlim(0, 1)
plt.grid(axis='x', linestyle='--', alpha=0.7)

# Annotate each bar with percentage
for i, value in enumerate(delay_rate):
    plt.text(value + 0.02, i, f"{value:.1%}", va='center', fontsize=9)

plt.tight_layout()
plt.show()

"""## **BOXPLOT**

## **Boxplot for flight number**
"""

plt.title('BOX PLOT FOR FLIGHT NUMBER')
sns.boxplot(x='Flight Number', data=df)
plt.show()

"""## **Boxpot for distance and carrier**

**The above boxplot is for determining outliers for the flight number being travelled. No irrelavent flight numbers were found as it has no outliers**
"""

plt.title('BOX PLOT FOR DISTANCE AND CARRIER')
sns.boxplot(x='Carrier',y='Distance',data=df,palette='rainbow')
plt.show()

"""**Box plot for distance and carrier is been plotted to find the outliers**

### **Plotting On-Time and Delayed status of flight**
"""

#count of flights which were ontime and delayed
t=df['Delayed'].value_counts()
plt.title('FLIGHTS ON-TIME VS DELAYED')
sns.histplot(x='Delayed',color='brown',shrink=0.5,data=df)
plt.show()

"""**This visualization shows the number of flights which were on-time and delayed.**

- Most of the flights are On-Time.
- Few flights were Delayed.

### **Plot for the status of flight based on Origin**
"""

#determining flights from origin based on arrival
plt.title('FLIGHTS FROM ORIGIN')
sns.histplot(x='Delayed',hue='Origin',palette='CMRmap',binwidth=.8,shrink=.5,multiple='dodge',data=df)
plt.show()

"""**This plot shows the status of number of flights which were from various origin. We can see that many flights reached On Time and small proportion of flights were late.**

**On-Time stats**

- DCA has most number flights which were - - On-Time compared with others
- Flights from BWI were less on time

**Delayed stats**

- More number flights got delayed from DCA
- BWI has less number of delayed flights

## **Plot for the status of flight based on Carrier**
"""

# determining flights from carrier based on arrival
plt.subplot()
plt.title('FLIGHTS FROM CARRIER')
sns.histplot(data=df,x='Delayed',hue='Carrier',palette='inferno',shrink=.5,multiple='dodge')
plt.show()

"""**This plot shows the status of number of flights which were from various carrier. We can see that many flights reached on time from Carrier and small proportion of flights were late.**

### **On-Time stats**

- DH has most number flights which were On-Time compared with others
- Flights from OH were less on time

### **Delayed stats**

- More number flights got delayed from DH
- OH has less number of delayed flights

## **Plot for the status of flight based on Destination**
"""

#determining flights from destination based on arrival
plt.title('FLIGHTS TO DESTINATION')
sns.histplot(x='Delayed',hue='Destination',palette='CMRmap',binwidth=.8,shrink=.5,multiple='dodge',data=df)
plt.show()

"""**This plot shows the status of number of flights which reached different destinations.**

### **On-Time stats**

- LGA has most number where flights reached - On-Time compared with others
- Flights from JFK were less on time

### **Delayed stats**

- More number flights got delayed to reach LGA
- JFK has less number of delayed flights

## **Relplot for arrival of flights based on destination**
"""

#showing the arrival of flight based on its destination
y=sns.relplot(data=df,x='Departure Time',y='Delayed',kind='line',col='Destination')
y.fig.suptitle("FLIGHTS TO DESTINATION BASED ON TIME")
plt.subplots_adjust(top=0.85)
plt.show()

"""**This relplot shows the relation between departure time of the flight and status of the flight.**

- Flights between 18 to 20 hours and above22.5 hours has reached the destination JFK1 getting `Delayed
- Most of Flights reaching LGA were On-Time
- Flights between 10 to 11 hours and at 22  hours has Delayed flight for destiantion EWR

**Showing the flight traffic based on days in a week**
"""

#flight traffic on days in a week
plt.title('FLIGHT TRAFFIC BASED ON DAYS')
sns.histplot(x='Day of the Week',data=df,shrink=2,color='Green')
plt.show()

"""**This chart shows the flight tarffic for each day in a week**

- Friday has more traffic than anyother days
- Saturday has less traffic than other days

**Showing the flight traffic based on monthly days**
"""

#flight traffic on days in a month
plt.title('FLIGHT TRAFFIC BASED ON MONTHS')
sns.histplot(x='Day of the Month',data=df,color='Brown')
plt.show()

"""**This chart shows the flight tarffic for each day in a month**

- Day 30 has more traffic than anyother days
- Day 10 to 12 has less traffic than other days

## **Occurence of carrier variable**
"""

#occurence of carrier variable
plt.title('CARRIER')
sns.histplot(data=df,x='Carrier',color='Brown')
plt.show()

"""**This plot shows the distribution of the carrier variables(occurence of the carrier variable)**

- DH has repeated more time
- OH and UA are less repeated

## **Plotting the proportion of destination and origin part of the flight**
"""

#determing the most occurred destination and origin
plt.figure(figsize=(10,10))

plt.subplot(1,2,1)
origin_counts=df['Origin'].value_counts()
plt.title('ORIGIN OF FLIGHT')
color=sns.color_palette('Set2')
plt.pie(x=origin_counts.values,labels=origin_counts.index,autopct='%1.1f%%',colors=color)

plt.subplot(1,2,2)
destination_counts=df['Destination'].value_counts()
plt.title('DESTINATION OF FLIGHT')
color=sns.color_palette('coolwarm')
plt.pie(x=destination_counts.values,labels=destination_counts.index,autopct='%1.1f%%',colors=color)

plt.show()

"""**This pie-chart shows the individual count of flight for destination and origin along with their percentile.**

### **ORIGIN**

- DCA has most of the flight origin than other two
- BWI has less number of origin of flight than other two.

### **DESTINATION**

- LGA has more arrival than other two
- JFK has less number of arrial than other two

## **Flight reach on days in a week**
"""

#Determining the status of flight traffic in a week
plt.title('FLIGHTS REACH BASED ON DAYS IN A WEEK')
sns.barplot(x='Delayed',y='Day of the Week',hue='Destination',palette='inferno',data=df)
plt.legend(bbox_to_anchor=(1.05,1),loc='upper left',borderaxespad=0.)
plt.show()

"""This plot shows the status of number of flights which reached the destinations on different days in a week.

### **On-Time stats**

- JFK has reached mostly on 5th day
- LGA has reached nearly to the4th day
- EWR has reached mostly on 4th day

### **Delayed stats**

- JFK has reached mostly on 5th day
- LGA has reached mostly in between 3rd and 4th day
- EWR has reached mostly in between 3rd and 4th day

## **Flight reaching on days in a week**
"""

#Determining the status of flight traffic in a month
plt.title('FLIGHTS REACHING DESTINATION BASED ON DAYS IN A MONTH')
sns.barplot(x='Delayed',y='Day of the Month',hue='Destination',palette='inferno',data=df)
plt.legend(bbox_to_anchor=(1.05,1),loc='upper left',borderaxespad=0.)
plt.show()

"""**This plot shows the status of number of flights which reached the destinations on different days in a month.**

## **On-Time stats**

- JFK,LGA,EWR has reached mostly on 16th day in a month

### **Delayed stats**

- JFK has reached mostly on 17th day
- LGA has reached mostly on 18th day
- EWR has reached mostly on 16th day

## **Plotting for distance and origin of flight**
"""

#stripplot for distance and origin of the flight
sns.stripplot(x='Distance',y='Origin',data=df,dodge=True,palette='gist_heat_r')

"""**This strip plot marks the relation between distance and origin**

- DCA has more origin at a distance of 210 to 220
- IAD has more origin at a distance of 220 to 230

### **Jointplots for plotting flight number and status of the fight**
"""

#joint plot for flight number and delayed parameter
sns.jointplot(x='Flight Number',y='Delayed',data=df)

"""**This jointplot shows the relation between flight number and delay time as a scatter and histplot.**

- Maximum he flights were On-time
- Flight number ranging between 2000 and 3000 were more On-time.

## **MODEL TRAINING**

**Various Machine Learning algorithms are used to train a model to give a prediction based on the available datas. Many functions and libraries are used for precise prediction of data. Various algorithms are used for predicting the desired parameters. One such method used in this system is the Naive Bayes Probabilty theorem for predicting values**

### **Naive bayes can be classified into three types namely**
    
    GAUSSIAN     : for continous data
    MULTINOMIAL  : for discrete data
    BERNOULLI    : for binary data
    

### **Gaussian model is used here for the prediction**

**To predict accurately, only essential features are required and others can be dropped Here the essential features are**

- Carrier
- Departure time
- Destination
- Origin
- Day of the week

**Having 5 number of features, a target variable is fixed which is Delayed in our case**

**A temporary variable is created for storing only the essential features required to train the model.**
"""

#dropping of unwanted features and assigning necessary features
temp=['Day of the Month','Flight Number','Date','Distance']
inputs=df.drop(temp,axis=1)

inputs

"""**This new data has 5 features and also the target variable delayed**

**Certain libraries are imported for predicitng the features and to produce the output. With these libraries, models are trained based on probablity theorem such as Naive Bayes which is been used in our prediction.**
"""

#importing libraries for training the model
from sklearn.preprocessing import LabelEncoder
from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.metrics import accuracy_score, precision_score, recall_score

"""**Also models could predict only the numerical datas (only numbers).**

**Features which having categorical datas are converted into numerical data using various methods are known as encoding.**

**There are several encoding methods been used such as**

- OneHotLabel
- LabelEncoder
- BinaryEncoding

**Label encoding type is used in here to convert categorical data into numerical data**

- This method assigns unique numerical value to each category having similar values. Target feature has also been converted into numerical data as the prediction is based on the target feature - Delayed -0 - Ontime -1
"""

le=LabelEncoder()

dfle=inputs
dfle.Carrier=le.fit_transform(dfle.Carrier)
dfle.Destination=le.fit_transform(dfle.Destination)
dfle.Origin=le.fit_transform(dfle.Origin)
dfle.Delayed=le.fit_transform(dfle.Delayed)
dfle

"""### **Target feature has been assigned**"""

# Delayed is set as target variable
target=dfle.Delayed
target

"""#### **It is essential to seperate the target variable from the other feature so that the datasplit occurs without any errors. Target feature gets dropped from other columns and stored in a different variable**"""

#seperation of target feature
gets=dfle.drop('Delayed',axis='columns')
gets

"""### **TEST-TRAIN SPLIT**

**Model will be trained based on the train and test splitting of data. Generally 80% of data will be used for training the model and 20% of data as testing model. Based on the training model, the model will be trained to predict the results of the testing data.**

**Our model contains 2199 number of datas where 2100 are split into training model and other 99 as testing model**
"""

#spliting of dataset with correct proportion
x_train,x_test,y_train,y_test=train_test_split(gets,target,test_size=99,random_state=5)

#displaying x train set variable
x_train

"""### **Length of train and test is evaluated to check the correctness of data split**"""

len(x_train)

len(x_test)

#displaying y train set variable
y_train

#displaying y test set variable
y_test

len(y_train)

len(y_test)

"""**Training and test datas are correctly splitted as mentioned**

**As our model consists of continous data, Gaussian method of Naive Bayes is used for prediction of flight status**
"""

for col in x_train.columns:
    if x_train[col].apply(lambda x: isinstance(x, pd.Interval)).any():
        print("Interval column:", col)

# Replace intervals with their left bound
for col in x_train.columns:
    if x_train[col].apply(lambda x: isinstance(x, pd.Interval)).any():
        x_train[col] = x_train[col].apply(lambda x: x.left)
        x_test[col] = x_test[col].apply(lambda x: x.left)

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, confusion_matrix

# Initialize
rf_model = RandomForestClassifier(random_state=42)

# Fit
rf_model.fit(x_train, y_train)

# Predict
rf_pred = rf_model.predict(x_test)
rf_proba = rf_model.predict_proba(x_test)[:,1]

# Metrics
print("Random Forest Classifier Metrics:")
print("Accuracy:", accuracy_score(y_test, rf_pred))
print("Precision:", precision_score(y_test, rf_pred))
print("Recall:", recall_score(y_test, rf_pred))
print("F1 Score:", f1_score(y_test, rf_pred))
print("ROC AUC:", roc_auc_score(y_test, rf_proba))

print("Train shape:", x_train.shape, y_train.shape)
print("Test shape:", x_test.shape, y_test.shape)

# Check intersection of indices (if you didn't reset indices)
intersection = set(x_train.index).intersection(set(x_test.index))
print("Overlapping rows:", len(intersection))

# Combine X and y to inspect correlations
import pandas as pd

# If y_train is a Series, reset index to align
train_df = pd.concat([x_train.reset_index(drop=True), y_train.reset_index(drop=True)], axis=1)

# Show correlation with target column
correlations = train_df.corr()

# Print correlations with the target
print(correlations.iloc[-1].sort_values(ascending=False))

# Drop the leaking column
x_train = x_train.drop(columns=['Delayed_numeric'])
x_test = x_test.drop(columns=['Delayed_numeric'])



from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, confusion_matrix

# Initialize
rf_model = RandomForestClassifier(random_state=42)

# Fit
rf_model.fit(x_train, y_train)

# Predict
rf_pred = rf_model.predict(x_test)
rf_proba = rf_model.predict_proba(x_test)[:,1]

# Metrics
print("Random Forest Classifier Metrics:")
print("Accuracy:", accuracy_score(y_test, rf_pred))
print("Precision:", precision_score(y_test, rf_pred))
print("Recall:", recall_score(y_test, rf_pred))
print("F1 Score:", f1_score(y_test, rf_pred))
print("ROC AUC:", roc_auc_score(y_test, rf_proba))

from sklearn.linear_model import LogisticRegression

# Initialize
logreg_model = LogisticRegression(max_iter=1000, random_state=42)

# Fit
logreg_model.fit(x_train, y_train)

# Predict
logreg_pred = logreg_model.predict(x_test)
logreg_proba = logreg_model.predict_proba(x_test)[:,1]

# Metrics
print("Logistic Regression Metrics:")
print("Accuracy:", accuracy_score(y_test, logreg_pred))
print("Precision:", precision_score(y_test, logreg_pred))
print("Recall:", recall_score(y_test, logreg_pred))
print("F1 Score:", f1_score(y_test, logreg_pred))
print("ROC AUC:", roc_auc_score(y_test, logreg_proba))

x_train = x_train.drop(columns=['Delayed', 'Delayed_numeric'], errors='ignore')
x_test = x_test.drop(columns=['Delayed', 'Delayed_numeric'], errors='ignore')

from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()

# Encode categorical columns
for col in x_train.select_dtypes(include=['object', 'category']).columns:
    x_train[col] = le.fit_transform(x_train[col])
    x_test[col] = le.transform(x_test[col])

from xgboost import XGBClassifier

# Initialize
xgb_model = XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42)

# Fit
xgb_model.fit(x_train, y_train)

# Predict
xgb_pred = xgb_model.predict(x_test)
xgb_proba = xgb_model.predict_proba(x_test)[:,1]

# Metrics
print("XGBoost Classifier Metrics:")
print("Accuracy:", accuracy_score(y_test, xgb_pred))
print("Precision:", precision_score(y_test, xgb_pred))
print("Recall:", recall_score(y_test, xgb_pred))
print("F1 Score:", f1_score(y_test, xgb_pred))
print("ROC AUC:", roc_auc_score(y_test, xgb_proba))

from sklearn.svm import SVC

# Initialize
svc_model = SVC(probability=True, random_state=42)

# Fit
svc_model.fit(x_train, y_train)

# Predict
svc_pred = svc_model.predict(x_test)
svc_proba = svc_model.predict_proba(x_test)[:,1]

# Metrics
print("Support Vector Classifier Metrics:")
print("Accuracy:", accuracy_score(y_test, svc_pred))
print("Precision:", precision_score(y_test, svc_pred))
print("Recall:", recall_score(y_test, svc_pred))
print("F1 Score:", f1_score(y_test, svc_pred))
print("ROC AUC:", roc_auc_score(y_test, svc_proba))

from sklearn.linear_model import LogisticRegression

# Initialize
logreg_model = LogisticRegression(max_iter=1000, random_state=42)

# Fit
logreg_model.fit(x_train, y_train)

# Predict
logreg_pred = logreg_model.predict(x_test)
logreg_proba = logreg_model.predict_proba(x_test)[:,1]

# Metrics
print("Logistic Regression Metrics:")
print("Accuracy:", accuracy_score(y_test, logreg_pred))
print("Precision:", precision_score(y_test, logreg_pred))
print("Recall:", recall_score(y_test, logreg_pred))
print("F1 Score:", f1_score(y_test, logreg_pred))
print("ROC AUC:", roc_auc_score(y_test, logreg_proba))

from sklearn.model_selection import GridSearchCV

param_grid_rf = {
    'n_estimators': [100, 200],
    'max_depth': [None, 10, 20],
    'min_samples_split': [2, 5],
}

grid_rf = GridSearchCV(RandomForestClassifier(random_state=42),
                       param_grid_rf,
                       scoring='f1',
                       cv=3)

grid_rf.fit(x_train, y_train)

print("Random Forest Best Params:", grid_rf.best_params_)
print("Best F1 Score:", grid_rf.best_score_)

param_grid_xgb = {
    'n_estimators': [100, 200],
    'max_depth': [3, 6, 10],
    'learning_rate': [0.01, 0.1, 0.3],
}

grid_xgb = GridSearchCV(XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42),
                        param_grid_xgb,
                        scoring='f1',
                        cv=3)

grid_xgb.fit(x_train, y_train)

print("XGBoost Best Params:", grid_xgb.best_params_)
print("Best F1 Score:", grid_xgb.best_score_)

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import GridSearchCV

# Define parameter grid
param_grid_rf = {
    'n_estimators': [100, 200],
    'max_depth': [None, 10, 20],
    'min_samples_split': [2, 5]
}

# Grid Search
grid_rf = GridSearchCV(
    estimator=RandomForestClassifier(random_state=42),
    param_grid=param_grid_rf,
    scoring='f1',
    cv=10,
    verbose=1,
    n_jobs=-1
)

grid_rf.fit(x_train, y_train)

# Results
print("Best Random Forest Parameters:", grid_rf.best_params_)
print("Best F1 Score on CV:", grid_rf.best_score_)

from xgboost import XGBClassifier

# Define parameter grid
param_grid_xgb = {
    'n_estimators': [100, 200],
    'max_depth': [3, 6, 10],
    'learning_rate': [0.01, 0.1, 0.3]
}

# Grid Search
grid_xgb = GridSearchCV(
    estimator=XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42),
    param_grid=param_grid_xgb,
    scoring='f1',
    cv=10,
    verbose=1,
    n_jobs=-1
)

grid_xgb.fit(x_train, y_train)

# Results
print("Best XGBoost Parameters:", grid_xgb.best_params_)
print("Best F1 Score on CV:", grid_xgb.best_score_)

grid_rf.best_params_

grid_rf.best_score_

grid_xgb.best_params_

grid_xgb.best_score_

pip install pycaret

import pandas as pd
from pycaret.classification import *

df = pd.read_csv('/content/Flight-Data.csv')

df.info()

df.columns

df.isnull().sum().plot(kind = 'barh')

df['Delayed '].value_counts().plot(kind = 'pie',autopct = '%1.2f')

# Use 'Delayed' as the target column (y)
X = df.drop('Delayed ', axis=1)
y = df['Delayed ']

from sklearn.preprocessing import MinMaxScaler,RobustScaler
from sklearn.metrics import accuracy_score,confusion_matrix,classification_report
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from imblearn.over_sampling import SMOTE

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()

for col in X_train.select_dtypes(include=['object', 'category']).columns:
    X_train[col] = le.fit_transform(X_train[col])
    X_test[col] = le.transform(X_test[col])

from imblearn.over_sampling import SMOTE

sm = SMOTE(random_state=42)
X_train_resampled, y_train_resampled = sm.fit_resample(X_train, y_train)

print("Before SMOTE:")
print(pd.Series(y_train).value_counts())
print("\nAfter SMOTE:")
print(pd.Series(y_train_resampled).value_counts())

rf = RandomForestClassifier()
rf.fit(X_train,y_train)
y_pred = rf.predict(X_test)

accuracy_score(y_test,y_pred)

# USing Randomized search cv

from sklearn.model_selection import RandomizedSearchCV
param_dist = {
    'n_estimators': [50, 100, 200, 300,500],
    'max_depth': [None, 10, 20, 30, 40,1000],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4],
    'bootstrap': [True, False]
}

rscv = RandomizedSearchCV(
    estimator=rf,
    param_distributions=param_dist,
    n_iter=11,
    cv=10,
    verbose=2,
    random_state=42,
    n_jobs=-1
)

rscv.fit(X_train, y_train)

# Best model
best_model = rscv.best_estimator_

# Predictions
y_pred = best_model.predict(X_test)

# Accuracy
print("Best Parameters:", rscv.best_params_)
print("Test Accuracy:", accuracy_score(y_test, y_pred))

from sklearn.model_selection import KFold

kf = KFold(n_splits=10, shuffle=True, random_state=42)
model = RandomForestClassifier(random_state=42)

scores = []

for train_idx, val_idx in kf.split(X_train):
    X_tr, X_val = X_train.iloc[train_idx], X_train.iloc[val_idx]
    y_tr, y_val = y_train.iloc[train_idx], y_train.iloc[val_idx]

    model.fit(X_tr, y_tr)
    y_pred = model.predict(X_val)

    acc = accuracy_score(y_val, y_pred)
    scores.append(acc)
scores

sum(scores) / len(scores)

!pip install gradio

import pandas as pd

# For LabelEncoder (same encoder you used during training)
le = LabelEncoder()

# Re-fit encoders to be able to transform user inputs
for col in X.select_dtypes(include=['object', 'category']).columns:
    le.fit(X[col])

# List of feature names
feature_names = list(X.columns)

def predict_delay(*inputs):
    # Create a DataFrame with one row
    input_df = pd.DataFrame([inputs], columns=feature_names)

    # Encode categorical columns
    for col in input_df.select_dtypes(include=['object', 'category']).columns:
        input_df[col] = le.transform(input_df[col])

    # Predict
    pred = rf_model.predict(input_df)[0]
    return "Delayed" if pred == 1 else "On Time"

import gradio as gr

inputs = [
    gr.Textbox(label="Carrier"),
    gr.Number(label="Departure Time"),
    gr.Number(label="Distance")
]

gr.Interface(
    fn=predict_delay,
    inputs=inputs,
    outputs=gr.Textbox(label="Prediction"),
    title="Flight Delay Predictor",
    description="Enter flight details to predict delay status."
).launch()

import pandas as pd
import gradio as gr

# Example LabelEncoder for Carrier (make sure you re-fit this on your data)
from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()
le.fit(X['Carrier'])

# Example model (use your trained model)
# rf_model = your trained model (RandomForest, etc.)

def predict_delay(Carrier, Departure_Time, Distance):
    try:
        # Build DataFrame
        input_df = pd.DataFrame(
            [[Carrier, Departure_Time, Distance]],
            columns=['Carrier', 'Departure Time', 'Distance']
        )

        # Debug print (see what data arrives)
        print("Input DataFrame:\n", input_df)

        # Validate Carrier
        if Carrier not in le.classes_:
            return f"Error: Carrier '{Carrier}' not recognized. Must be one of {list(le.classes_)}."

        # Encode Carrier
        input_df['Carrier'] = le.transform(input_df['Carrier'])

        # Predict
        pred = rf_model.predict(input_df)[0]
        return "Delayed" if pred == 1 else "On Time"

    except Exception as e:
        print("Error occurred:", e)
        return f"Error: {str(e)}"

# Gradio app
interface = gr.Interface(
    fn=predict_delay,
    inputs=[
        gr.Textbox(label="Carrier"),
        gr.Number(label="Departure Time"),
        gr.Number(label="Distance")
    ],
    outputs=gr.Textbox(label="Prediction"),
    title="Flight Delay Predictor",
    description="Enter flight details to predict delay status."
)

interface.launch()

